---
Title: Access the free economic database DBnomics with R
date: 2020-10-20
Category: Data
Tags: DBnomics, database, R
Slug: rdbnomics-tutorial
Authors: Thomas Brand, SÃ©bastien Galais
Summary: Access the whole economic database <a href="https://db.nomics.world/" target="_blank">DBnomics</a> for free from R.
Download: https://git.nomics.world/macro/macro.nomics.world/tree/master/content/rdbnomics-tutorial
output: html_document
---


# DBnomics: the world's economic database

Explore all the economic data from different providers (national and international statistical institutes, central banks, etc.), for free, following the link <a href="https://db.nomics.world/" target="_blank">db.nomics.world</a>.

![]({filename}/images/dbnomics001.png){width=750px}

You can also retrieve all the economic data through the `rdbnomics` package <a href="https://cran.r-project.org/web/packages/rdbnomics/index.html" target="_blank">here</a>. This blog post describes the different ways to do so.

# Fetch time series by `ids`

First, let's assume that we know which series we want to download. A series identifier (`ids`) is defined by three values, formatted like this: `provider_code`/`dataset_code`/`series_code`.

## Fetch one series from dataset 'Unemployment rate' (ZUTN) of AMECO provider

```{r, echo = FALSE}
library <- function(...) {
  suppressWarnings(
    suppressPackageStartupMessages(base::library(..., quietly = TRUE))
  )
}
```

```{r, message=FALSE, warning=FALSE, echo=FALSE, results='hide'}
if (!"pacman" %in% installed.packages()[,"Package"]) install.packages("pacman", repos='http://cran.r-project.org')
pacman::p_load(tidyverse,rdbnomics,magrittr,lubridate,knitr,zoo,kableExtra)
opts_chunk$set(fig.align="center", message=FALSE, warning=FALSE, cache=FALSE)
```

```{r, echo = FALSE}
reorder_cols <- function(x) {
  cols <- c(
    "provider_code", "dataset_code", "dataset_name", "series_code",
    "series_name", "original_period", "period", "original_value", "value",
    "@frequency"
  )

  if ("unit" %in% colnames(x)) {
    cols <- c(cols, "unit", "Unit")
  }

  if ("geo" %in% colnames(x)) {
    cols <- c(cols, "geo", "Country")
  }

  if ("freq" %in% colnames(x)) {
    cols <- c(cols, "freq", "Frequency")
  }

  cols_add <- setdiff(colnames(x), cols)
  cols <- c(cols, cols_add)

  cols <- cols[cols %in% colnames(x)]
  
  cols <- match(cols, colnames(x))

  dplyr::select(x, cols)
}

scale_colour_discrete <- function(...) {
  scale_color_brewer(palette = "Set1")
}

knitr::opts_chunk$set(dev.args = list(bg = "transparent"))

dbnomics <- function() {
  list(
    scale_x_date(expand = c(0, 0)),
    scale_y_continuous(labels = function(x) { format(x, big.mark = " ") }),
    xlab(""),
    ylab(""),
    theme_bw(),
    theme(
      legend.position = "bottom", legend.direction = "vertical",
      legend.background = element_rect(fill = "transparent", colour = NA),
      legend.key = element_blank(),
      panel.background = element_rect(fill = "transparent", colour = NA),
      plot.background = element_rect(fill = "transparent", colour = NA),
      legend.title = element_blank()
    ),
    annotate(
      geom = "text", label = "DBnomics <https://db.nomics.world>", 
      x = structure(Inf, class = "Date"), y = -Inf,
      hjust = 1.1, vjust = -0.4, col = "grey", 
      fontface = "italic"
    )
  )
}

display_table <- function(DT) {
  kable(DT) %>% 
    #kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
    #kable_paper() %>% 
    kableExtra::column_spec(1:ncol(DT),width_min="4cm") %>% 
    kableExtra::scroll_box(width = "100%", height = "500px")
}
```

```{r}
df <- rdb(ids = 'AMECO/ZUTN/EA19.1.0.0.0.ZUTN') %>%
  filter(!is.na(value))
```

In such data.frame (data.table or tibble), you will always find at least ten columns:

- `provider_code`
- `dataset_code`
- `dataset_name`
- `series_code`
- `series_name`
- `original_period` (character string)
- `period` (date of the first day of `original_period`)
- `original_value` (character string)
- `value`
- `@frequency` (harmonized frequency generated by DBnomics)

The other columns depend on the provider and on the dataset. They always come in pairs (for the code and the name). In the data.frame `df`, you have:

- `unit` (code) and `Unit` (name)
- `geo` (code) and `Country` (name)
- `freq` (code) and `Frequency` (name)

```{r, echo = FALSE}
df %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

In the event that you only use the argument `ids`, you can drop it and run:
```{r}
df <- rdb('AMECO/ZUTN/EA19.1.0.0.0.ZUTN')
```

## Fetch two series from dataset 'Unemployment rate' (ZUTN) of AMECO provider

```{r}
df <- rdb(ids = c('AMECO/ZUTN/EA19.1.0.0.0.ZUTN', 'AMECO/ZUTN/DNK.1.0.0.0.ZUTN')) %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  arrange(series_code, period) %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

## Fetch two series from different datasets of different providers

```{r}
df <- rdb(ids = c('AMECO/ZUTN/EA19.1.0.0.0.ZUTN', 'Eurostat/une_rt_q/Q.SA.Y15-74.PC_ACT.T.EA19')) %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  arrange(series_code, period) %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics() + 
  theme(legend.text = element_text(size=7))
```

# Fetch time series by `mask`
The code mask notation is a very concise way to select one or many time series at once.

## Fetch one series from dataset 'Balance of Payments' (BOP) of IMF
```{r}
df <- rdb('IMF', 'BOP', mask = 'A.FR.BCA_BP6_EUR') %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

In the event that you only use the arguments `provider_code`, `dataset_code` and `mask`, you can drop the name `mask` and run:
```{r}
df <- rdb('IMF', 'BOP', 'A.FR.BCA_BP6_EUR')
```

## Fetch two series from dataset 'Balance of Payments' (BOP) of IMF

You just have to add a `+` between two different values of a dimension.
```{r}
df <- rdb('IMF', 'BOP', mask = 'A.FR+ES.BCA_BP6_EUR') %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  arrange(series_code, period) %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

## Fetch all series along one dimension from dataset 'Balance of Payments' (BOP) of IMF

```{r}
df <- rdb('IMF', 'BOP', mask = 'A..BCA_BP6_EUR') %>%
  filter(!is.na(value)) %>%
  arrange(desc(period), REF_AREA) %>%
  head(100)
```

```{r, echo = FALSE}
df %>%
  reorder_cols() %>%
  display_table()
```

## Fetch series along multiple dimensions from dataset 'Balance of Payments' (BOP) of IMF

```{r}
df <- rdb('IMF', 'BOP', mask = 'A.FR+ES.BCA_BP6_EUR+IA_BP6_EUR') %>%
  filter(!is.na(value)) %>%
  group_by(INDICATOR) %>%
  top_n(n = 50, wt = period)
```

```{r, echo = FALSE}
df %>%
  reorder_cols() %>%
  display_table()
```

# Fetch time series by `dimensions`
Searching by `dimensions` is a less concise way to select time series than using the code `mask`, but it works with all the different providers. You have a "*Description of series code*" at the bottom of each dataset page on the <a href="https://db.nomics.world/" target="_blank">DBnomics website</a>.

## Fetch one value of one dimension from dataset 'Unemployment rate' (ZUTN) of AMECO provider

```{r}
df <- rdb('AMECO', 'ZUTN', dimensions = list(geo = "ea19")) %>%
  filter(!is.na(value))
```
or
```{r}
df <- rdb('AMECO', 'ZUTN', dimensions = '{"geo":["ea19"]}') %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

## Fetch two values of one dimension from dataset 'Unemployment rate' (ZUTN) of AMECO provider

```{r}
df <- rdb('AMECO', 'ZUTN', dimensions = list(geo = c("ea19", "dnk"))) %>%
  filter(!is.na(value))
```
or
```{r}
df <- rdb('AMECO', 'ZUTN', dimensions = '{"geo":["ea19","dnk"]}') %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  arrange(series_code, period) %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

## Fetch several values of several dimensions from dataset 'Doing business' (DB) of World Bank

```{r}
df <- rdb('WB', 'DB', dimensions = list(country = c("DZ", "PE"), indicator = c("ENF.CONT.COEN.COST.ZS", "IC.REG.COST.PC.FE.ZS"))) %>%
  filter(!is.na(value))
```
or
```{r}
df <- rdb('WB', 'DB', dimensions = '{"country":["DZ","PE"],"indicator":["ENF.CONT.COEN.COST.ZS","IC.REG.COST.PC.FE.ZS"]}') %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  arrange(series_name, period) %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

# Fetch time series with a `query`
The query is a Google-like search that will filter/select time series from a provider's dataset.

## Fetch one series from dataset 'WEO by countries' (WEO) of IMF
```{r}
df <- rdb('IMF', 'WEO:latest', query = "France current account balance percent") %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  arrange(series_name, period) %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

## Fetch series from dataset 'WEO by countries' (WEO) of IMF
```{r}
df <- rdb('IMF', 'WEO:2010-04', query = "current account balance percent") %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  arrange(series_name, period) %>%
  reorder_cols() %>%
  head() %>% 
  display_table()
```

# Fetch time series found on the web site

When you don't know the codes of the dimensions, provider, dataset or series, you can:

- go to the page of a dataset on <a href="https://db.nomics.world/" target="_blank">DBnomics website</a>, for example <a href="https://db.nomics.world/WB/DB" target="_blank">Doing Business</a>,  

- select some dimensions by using the input widgets of the left column,
![]({filename}/images/dbnomics002.png){width=60%}

- click on "*Copy API link*" in the menu of the "*Download*" button,
![]({filename}/images/dbnomics003.png){width=60%}  

- use the `rdb(api_link = ...)` function such as below.  

```{r}
df <- rdb(api_link = "https://api.db.nomics.world/v22/series/WB/DB?dimensions=%7B%22country%22%3A%5B%22FR%22%2C%22IT%22%2C%22ES%22%5D%7D&q=IC.REG.PROC.FE.NO&observations=1&format=json&align_periods=1&offset=0&facets=0") %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %>%
  arrange(period, series_name) %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_step(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```

In the event that you only use the argument `api_link`, you can drop the name and run:
```{r}
df <- rdb("https://api.db.nomics.world/v22/series/WB/DB?dimensions=%7B%22country%22%3A%5B%22FR%22%2C%22IT%22%2C%22ES%22%5D%7D&q=IC.REG.PROC.FE.NO&observations=1&format=json&align_periods=1&offset=0&facets=0")
```

# Fetch time series from the cart

On the cart page of the <a href="https://db.nomics.world/" target="_blank">DBnomics website</a>, click on "*Copy API link*" and copy-paste it as an argument of the `rdb(api_link = ...)` function. Please note that when you update your cart, you have to copy this link again, because the link itself contains the ids of the series in the cart.
<center>
![]({filename}/images/dbnomics004.png){width=75%}
</center>
  
```{r}
df <- rdb(api_link = "https://api.db.nomics.world/v22/series?observations=1&series_ids=BOE/6008/RPMTDDC,BOE/6231/RPMTBVE") %>%
  filter(!is.na(value))
```

```{r, echo = FALSE}
df %<>%
  mutate(
    series_name = sapply(
      series_name,
      function(y) {
        paste0(
          paste0(
            strsplit(y, "institutions' ")[[1]], collapse = "institutions'\n"
          ),
          "\n"
        )
      }
    )
  )
```

```{r, echo = FALSE}
df %>%
  arrange(period, series_name) %>%
  reorder_cols() %>%
  display_table()
```

```{r}
ggplot(df, aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```


# Fetch the available datasets of a provider

When fetching series from <a href="https://db.nomics.world/" target="_blank">DBnomics</a>, you need to give a provider and a dataset before specifying correct dimensions. With the function `rdb_datasets`, you can download the list of the available datasets for a provider.  

For example, to fetch the **IMF** datasets, you have to use:
```{r}
DT <- rdb_datasets(provider_code = "IMF")
display_table(DT[[1]])
```

The result is a named list (its name is **IMF**) with one element which is a `data.table`.

With the same function, if you want to fetch the available datasets for multiple providers, you can give a vector of providers and get a named list.
```{r}
DT <- rdb_datasets(provider_code = c("IMF", "BDF"))
```

```{r}
DT <- sapply(DT, function(y) { paste0(": ", nrow(y)) })
DT <- paste0("Number of datasets for ", names(DT), " ", unname(DT))
cat(DT, sep = "\n")
```

In the event that you only request the datasets for one provider, if you define `simplify = TRUE`, then the result will be a `data.table`, not a named list.
```{r}
rdb_datasets(provider_code = "IMF", simplify = TRUE) %>% 
  display_table()
```

The extent of datasets gathered by <a href="https://db.nomics.world/" target="_blank">DBnomics</a> can be appreciate by using the function with the argument `provider_code` set to `NULL`:
```{r, eval = FALSE}
rdb_datasets()
```


# Fetch the possible dimensions of available datasets of a provider

When fetching series from <a href="https://db.nomics.world/" target="_blank">DBnomics</a>, it can be interesting and especially useful to specify dimensions for a particular dataset to download only the series you want to analyse. With the function `rdb_dimensions`, you can download these dimensions and their meanings.  

For example, for the dataset **WEO** of the **IMF**, you may use:
```{r}
DT <- rdb_dimensions(provider_code = "IMF", dataset_code = "WEO:latest")
```

The result is a nested named list (its names are **IMF**, **WEO** and the dimensions names) with a `data.table` at the end of each branch:
```{r}
DT_IMF_WEO <- DT$IMF$WEO
DTnb <- paste0("Number of dimensions for IMF/WEO:latest : ", length(DT_IMF_WEO))
cat(DTnb, sep = "\n")
```
The different values of the first dimension of IMF WEO are :
```{r}
display_table(DT_IMF_WEO[[1]])
```

In the event that you only request the dimensions for one dataset for one provider, if you define `simplify = TRUE`, then the result will be a named list, not a nested named list.
```{r}
DT <- rdb_dimensions(provider_code = "IMF", dataset_code = "WEO:latest", simplify = TRUE)
display_table(DT[[1]])
```

You can measure the vast extent of datasets gathered by <a href="https://db.nomics.world/" target="_blank">DBnomics</a> by downloading all the possible dimensions. To do this, you have to set the arguments `provider_code` and `dataset_code` to `NULL`.  

```{r, eval = FALSE}
rdb_dimensions()
```

# Fetch the series codes and names of available datasets of a provider

You can download the list of series, and especially their codes, of a dataset's provider by using the function `rdb_series`. The result is a nested named list with a `data.table` at the end of each branch. If you define `simplify = TRUE`, then the result will be a `data.table` not a nested named list.  

For example, for the **IMF** provider and the dataset **WEO**, the command is:
```{r}
rdb_series(provider_code = "IMF", dataset_code = "WEO:latest", simplify = TRUE) %>% 
  head() %>% 
  display_table()
```

Like the function `rdb()`, you can add features to `rdb_series()`. You can ask for the series with specific `dimensions`:

```{r}
rdb_series(provider_code = "IMF", dataset_code = "WEO:latest", dimensions = list(`weo-subject` = "NGDP_RPCH"), simplify = TRUE) %>% 
  display_table()
```
or with a `query`:
```{r}
DT <- rdb_series(provider_code = "IMF", dataset_code = c("WEO:latest", "WEOAGG:latest"), query = "NGDP_RPCH")
```

<b><font color='red'>&#9888;</font></b> We ask the user to use this function parsimoniously because there are a huge amount of series per dataset. Please only fetch for one dataset if you need it or visit the <a href="https://db.nomics.world/" target="_blank">DBnomics website</a>.


# Proxy configuration or connection error `Could not resolve host`

When using the function `rdb`, you may come across the following error:
```{r, eval = FALSE}
Error in open.connection(con, "rb") :
  Could not resolve host: api.db.nomics.world
```

To get round this situation, you have two options:

1. configure **curl** to use a specific and authorized proxy.

2. use the default R internet connection i.e. the Internet Explorer proxy defined in *internet2.dll*.

## Configure **curl** to use a specific and authorized proxy

In **rdbnomics**, by default the function `curl_fetch_memory` (of the package **curl**) is used to fetch the data. If a specific proxy must be used, it is possible to define it permanently with the package option `rdbnomics.curl_config` or on the fly through the argument `curl_config`. Because the object is a named list, its elements are passed to the connection (the `curl_handle` object created internally with `new_handle()`) with `handle_setopt()` before using `curl_fetch_memory`.

To see the available parameters, run `names(curl_options())` in *R* or visit the website <a href="https://curl.haxx.se/libcurl/c/curl_easy_setopt.html" target="_blank">https://curl.haxx.se/libcurl/c/curl_easy_setopt.html</a>. Once they are chosen, you define the curl object as follows:
```{r, eval = FALSE}
h <- list(
  proxy = "<proxy>",
  proxyport = <port>,
  proxyusername = "<username>",
  proxypassword = "<password>"
)
```

### Set the connection up for a session

The curl connection can be set up for a session by modifying the following package option:
```{r, eval = FALSE}
options(rdbnomics.curl_config = h)
```
When fetching the data, the following command is executed:
```{r, eval = FALSE}
hndl <- curl::new_handle()
curl::handle_setopt(hndl, .list = getOption("rdbnomics.curl_config"))
curl::curl_fetch_memory(url = <...>, handle = hndl)
```

After configuration, just use the standard functions of **rdbnomics** e.g.:
```{r, eval = FALSE}
df1 <- rdb(ids = 'AMECO/ZUTN/EA19.1.0.0.0.ZUTN')
```
This option of the package can be disabled with:
```{r, eval = FALSE}
options(rdbnomics.curl = NULL)
```

### Use the connection only for a function call

If a complete configuration is not needed but just an "on the fly" execution, then use the argument `curl_config` of the function `rdb`:
```{r, eval = FALSE}
df1 <- rdb(ids = 'AMECO/ZUTN/EA19.1.0.0.0.ZUTN', curl_config = h)
```

## Use the default R internet connection

To retrieve the data with the default R internet connection, **rdbnomics** will use the base function `readLines`.

### Set the connection up for a session

To activate this feature for a session, you need to enable an option of the package:
```{r, eval = FALSE}
options(rdbnomics.use_readLines = TRUE)
```
And then use the standard function as follows:
```{r, eval = FALSE}
df1 <- rdb(ids = 'AMECO/ZUTN/EA19.1.0.0.0.ZUTN')
```
This configuration can be disabled with:
```{r, eval = FALSE}
options(rdbnomics.use_readLines = FALSE)
```

### Use the connection only for a function call

If you just want to do it once, you may use the argument `use_readLines` of the function `rdb`:
```{r, eval = FALSE}
df1 <- rdb(ids = 'AMECO/ZUTN/EA19.1.0.0.0.ZUTN', use_readLines = TRUE)
```

# Transform time series with filters

The **rdbnomics** package can interact with the *Time Series Editor* of DBnomics to transform time series by applying filters to them.  
Available filters are listed on the filters page <a href="https://editor.nomics.world/filters" target="_blank">https://editor.nomics.world/filters</a>. 

Here is an example of how to proceed to interpolate two annual time series with a monthly frequency, using a spline interpolation:

```{r}
filters <- list(
  code="interpolate",
  parameters=list(frequency="monthly",method="spline")
)
```

The request is then:

```{r}
df <- rdb(
  ids = c("AMECO/ZUTN/EA19.1.0.0.0.ZUTN"),
  filters = filters
)
```

If you want to apply more than one filter, the `filters` argument will be a list of valid filters:

```{r, eval = FALSE}
filters <- list(
  list(
    code = "interpolate",
    parameters = list(frequency = "monthly", method = "spline")
  ),
  list(
    code = "aggregate",
    parameters = list(frequency = "bi-annual", method = "end_of_period")
  )
)

df <- rdb(
  ids = c("AMECO/ZUTN/EA19.1.0.0.0.ZUTN", "AMECO/ZUTN/DNK.1.0.0.0.ZUTN"),
  filters = filters
)
```

The `data.table` columns change a little bit when filters are used. There are two new columns:

- `period_middle_day`: the middle day of `original_period` (can be useful when you compare graphically interpolated series and original ones).
- `filtered` (boolean): `TRUE` if the series is filtered, `FALSE` otherwise.

The content of two columns are modified:

- `series_code`: same as before for original series, but the suffix `_filtered` is added for filtered series.
- `series_name`: same as before for original series, but the suffix ` (filtered)` is added for filtered series.

```{r}
df %>% 
  head() %>% 
  display_table()

df <- df[order(filtered, series_name, period)]
df <- reorder_cols(df)
display_table(head(df))
```

```{r, echo = FALSE, fig.align = 'center'}
ggplot(df[!is.na(value)], aes(x = period, y = value, color = series_name)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  dbnomics()
```
